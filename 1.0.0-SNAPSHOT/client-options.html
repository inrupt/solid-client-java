<!DOCTYPE html>


<!--
 | Generated by Apache Maven Doxia Site Renderer 1.11.1 from src/site/apt/client-options.apt.vm at 2023-07-03
 | Rendered using Apache Maven Fluido Skin 1.11.1
-->
<html xmlns="http://www.w3.org/1999/xhtml" lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="generator" content="Apache Maven Doxia Site Renderer 1.11.1" />
    <title>Inrupt Java Client Libraries &#x2013; </title>
    <link rel="stylesheet" href="./css/apache-maven-fluido-1.11.1.min.css" />
    <link rel="stylesheet" href="./css/site.css" />
    <link rel="stylesheet" href="./css/print.css" media="print" />
    <script src="./js/apache-maven-fluido-1.11.1.min.js"></script>
  </head>
  <body class="topBarDisabled">
    <div class="container-fluid">
      <header>
        <div id="banner">
          <div class="pull-left"><div id="bannerLeft"><h1>Inrupt Java Client Libraries</h1>
</div>
</div>
          <div class="pull-right"><a href="index.html" id="bannerRight"><img src="images/inrupt_logo-2020.svg"  alt="Inrupt" style="" /></a></div>
          <div class="clear"><hr/></div>
        </div>

        <div id="breadcrumbs">
          <ul class="breadcrumb">
        <li id="publishDate">Last Published: 2023-07-03<span class="divider">|</span>
</li>
          <li id="projectVersion">Version: 1.0.0-SNAPSHOT</li>
          </ul>
        </div>
      </header>
      <div class="row-fluid">
        <header id="leftColumn" class="span2">
          <nav class="well sidebar-nav">
  <ul class="nav nav-list">
   <li class="nav-header">Inrupt Client</li>
    <li><a href="index.html" title="Home"><span class="none"></span>Home</a></li>
    <li><a href="getting-started.html" title="Getting Started"><span class="none"></span>Getting Started</a></li>
    <li><a href="usage-examples.html" title="Usage Examples"><span class="none"></span>Usage Examples</a></li>
    <li class="active"><a><span class="none"></span>Client Options</a></li>
    <li><a href="session-management.html" title="Session Management"><span class="icon-chevron-right"></span>Session Management</a></li>
    <li><a href="data-modeling.html" title="Data Modeling"><span class="icon-chevron-right"></span>Data Modeling</a></li>
    <li><a href="apidocs/" title="Documentation"><span class="none"></span>Documentation</a></li>
    <li><a href="licenses.html" title="License"><span class="none"></span>License</a></li>
    <li><a href="modules.html" title="Modules"><span class="none"></span>Modules</a></li>
  </ul>
          </nav>
          <div class="well sidebar-nav">
            <div id="poweredBy">
              <div class="clear"></div>
              <div class="clear"></div>
              <div class="clear"></div>
<a href="http://maven.apache.org/" title="Built by Maven" class="poweredBy"><img class="builtBy" alt="Built by Maven" src="./images/logos/maven-feather.png" /></a>
            </div>
          </div>
        </header>
        <main id="bodyColumn"  class="span10" >
<section>
<h2><a name="Client_Options"></a>Client Options</h2>
<p>An application can obtain a client for interacting with Solid data in several ways. This guide will help you decide how your application will retrieve, configure and use a client.</p><section>
<h3><a name="What_you_will_need"></a>What you will need</h3>
<ul>
<li><a class="externalLink" href="https://start.inrupt.com/profile">A Solid Pod</a></li>
<li>About 15 minutes</li>
<li>Your favorite text editor or IDE</li>
<li>Java 11 or later</li>
<li>Maven 3.5 or later</li></ul></section><section>
<h3><a name="How_to_complete"></a>How to complete</h3>
<p>Choose the type of client that best fits for your application. There are three types of clients available for use, each with the following characteristics:</p>
<ul>
<li><a href="#High-Level_Synchronous_Client"><b>High-Level Synchronous Client</b></a>. This client simplifies the basic Create-Read-Update-Delete operations you would expect in a RESTful client, while supporting a data binding mechanism between Java objects and Solid resources.</li>
<li><a href="#High-Level_Asynchronous_Client"><b>High-Level Asynchronous Client</b></a>. This client is exactly like the synchronous client except that all responses are wrapped in a <code>CompletionStage&lt;T&gt;</code>.</li>
<li><a href="#Low-Level_Asynchronous_Client"><b>Low-Level Asynchronous Client</b></a>. This client is considerably more verbose and gives developers full control over the HTTP requests and responses.</li></ul>
<p>For the low-level client, there is a single method to perform an HTTP operation: <code>Client::send</code>.</p>
<p>For the high-level clients, in addition to the low-level <code>::send</code> API, you will have several other methods available:</p>
<ul>
<li><code>&lt;T extends Resource&gt; ::create(T)</code> -- given an object that is a subclass of <code>Resource</code>, create a new Solid resource.</li>
<li><code>&lt;T extends Resource&gt; ::read(URI, Class&lt;T&gt;)</code> -- fetch a Solid resource from a known URI and marshall it into the given type.</li>
<li><code>&lt;T extends Resource&gt; ::update(T)</code> -- given an object that is a subclass of <code>Resource</code>, update an existing Solid resource.</li>
<li><code>&lt;T extends Resource&gt; ::delete(T)</code> -- given an object that is a subclass of <code>Resource</code>, delete the corresponding Solid resource.</li></ul></section><section>
<h3><a name="High-Level_Synchronous_Client"></a>High-Level Synchronous Client</h3>
<p>The high-level synchronous client, offers a RESTful API, allowing for synchronous interaction with Solid resources. In addition this client manages a data binding between the Java types you define and the underlying Solid resources.</p>
<div class="source"><pre class="prettyprint">import com.inrupt.client.solid.SolidRDFSource;
import com.inrupt.client.solid.SolidSyncClient;
import java.net.URI;

public class ClientSample {

    public void useTheHighLevelSyncClient() {
        SolidSyncClient client = SolidSyncClient.getClient();

        URI uri = URI.create(&quot;https://storage.example/resource.ttl&quot;);
        SolidRDFSource resource = client.read(uri, SolidRDFSource.class);
    }
}</pre></div></section><section>
<h3><a name="High-Level_Asynchronous_Client"></a>High-Level Asynchronous Client</h3>
<p>The high-level asynchronous client API is exactly like the synchronous API, except that the return types are wrapped in a <code>CompletionStage&lt;T&gt;</code>.</p>
<div class="source"><pre class="prettyprint">import com.inrupt.client.solid.SolidClient;
import com.inrupt.client.solid.SolidRDFSource;
import java.net.URI;
import java.util.concurrent.CompletionStage;

public class ClientSample {

    public CompletionStage&lt;SolidRDFSource&gt; useTheHighLevelAsyncClient() {
        SolidClient client = SolidClient.getClient();

        URI uri = URI.create(&quot;https://storage.example/resource.ttl&quot;);
        return client.read(uri, SolidRDFSource.class);
    }
}</pre></div></section><section>
<h3><a name="Low-Level_Asynchronous_Client"></a>Low-Level Asynchronous Client</h3>
<p>The low-level client API gives developers full control over HTTP requests and responses. This API is also considerably more verbose, while only including a single method: <code>::send</code>.</p>
<div class="source"><pre class="prettyprint">import com.inrupt.client.Client;
import com.inrupt.client.ClientProvider;
import com.inrupt.client.Request;
import com.inrupt.client.Response;
import java.net.URI;
import java.util.concurrent.CompletionStage;

public class ClientSample {

    public CompletionStage&lt;String&gt; useTheLowLevelClient() {
        Client client = ClientProvider.getClient();

        URI uri = URI.create(&quot;https://storage.example/resource.ttl&quot;);
        Request req = Request.newBuilder(uri)
            .header(&quot;Accept&quot;, &quot;text/turtle&quot;)
            .GET()
            .build();

        return client.send(req, Response.BodyHandlers.ofInputStream()).thenApply(res -&gt; {
                if (res.statusCode() == 200) {
                    return res.body().toString();
                }
                return &quot;Error accessing resource: &quot; + res.statusCode();
            });
    }
}</pre></div><section>
<h4><a name="Request_Body_Publishers"></a>Request Body Publishers</h4>
<p>Write operations such as <code>POST</code> and <code>PUT</code> will typically contain a request body. The low-level client provides a number of request body publishers for use by developers. These publishers make it easier to translate existing Java objects into HTTP requests. Some existing body publishers include:</p>
<ul>
<li><code>Request.BodyPublishers.ofString(String)</code> This publisher accepts a <code>String</code> and will convert that into an HTTP request body.</li>
<li><code>Request.BodyPublishers.ofInputStream(InputStream)</code> This publisher accepts an <code>InputStream</code>.</li>
<li><code>Request.BodyPublishers.noBody()</code> This publisher uses an empty body in the HTTP request.</li></ul>
<p>In addition, when working directly with RDF resources, there are Jena and RDF4J publishers that will serialize an RDF Model as an HTTP request. These handlers are useful in cases where applications are already using an RDF framework. In these cases, <code>JenaBodyPublishers.ofModel(Model, Lang)</code> or <code>RDF4JBodyPublishers.ofModel(Model, RDFFormat)</code> would be used.</p></section><section>
<h4><a name="Response_Body_Handlers"></a>Response Body Handlers</h4>
<p>The low-level client also provides a number of response body handlers for use by developers. The following body handlers are always available:</p>
<ul>
<li><code>Response.BodyHandlers.discarding()</code> This handler discards any response content. It is especially useful for write operations such as <code>PUT</code>, <code>POST</code> and <code>DELETE</code>.</li>
<li><code>Response.BodyHandlers.ofInputStream()</code> This handler maps the HTTP response to an <code>InputStream</code>. This may be useful for custom processing of the response body.</li>
<li><code>Response.BodyHandlers.ofString()</code> This handler maps the HTTP response to a <code>String</code>. This may be useful for small text-oriented responses, though one should generally prefer the <code>InputStream</code>-based API.</li></ul>
<p>When working with RDF resources, there are Jena and RDF4J handlers that will map HTTP responses directly to a Jena or RDF4J Model. These handlers are useful in cases where applications are already using an RDF framework. <code>JenaBodyHandlers.ofModel()</code> or <code>RDF4JBodyHandlers.ofModel()</code> would be used in these cases.</p></section></section><section>
<h3><a name="Next_Steps"></a>Next Steps</h3>
<p>Now that you have decided which client to use, the next step is to consider how to <a href="./session-management.html">manage authenticated sessions</a>.</p></section></section>
        </main>
      </div>
    </div>
    <hr/>
    <footer>
      <div class="container-fluid">
        <div class="row-fluid">
            <p>&#169;      2023
<a href="https://inrupt.com">Inrupt, Inc</a>
</p>
        </div>
      </div>
    </footer>
<script>
	if(anchors) {
	  anchors.add();
	}
</script>
  </body>
</html>
